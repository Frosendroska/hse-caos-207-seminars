#include <sys/syscall.h>

    .global _start
_start:
    // Системный вызов brk вернет адрес конца памяти (отличается от возвращаемого значения,
    // написанного в man 2 brk, так как в мане описана обертка над систенмым вызовом), которую мы запросили.
    // Память выделяется в куче.
    // Если мы сделаем вызов brk с аргументом 0, то получим адрес начала 
    // и одновременно конца доступной области памяти.
    mov     $SYS_brk, %eax
    mov     $0, %ebx
    int     $0x80

    // Сохраним полученый адрес начала кучи в heapstart
    mov     %eax, heapstart

    mov     %eax, %edx
    // Если попробуем что-то записать по этому адресу, то получим segfault.
    // Поскольку мы не просили ничего нам выделить
    // movl    $42, (%edx)

    // В brk нужно передать адрес конца памяти, до куда мы хотим ее выделить.
    // Выделим 1 МБ. Прибавим 2**20 к eax (в котором лежит сейчас адрес начала кучи)
    add     $1<<20, %eax
    // Переложим в ebx для того, чтобы сделать системный вызов
    mov     %eax, %ebx

    // Просим выделить нам память от heapstart до heapstart + 1<<20
    mov     $SYS_brk, %eax
    int     $0x80

    // Сохраним полученный адрес в heapend
    mov     %eax, heapend

    // Теперь уже не будет segfault поскольку память выделена
    // и мы можем туда что-то сложить
    // movl    $42, (%edx)

    mov     $SYS_exit, %eax
    mov     $0, %ebx
    int     $0x80

// Часть с my_malloc в коде не используется.
// Опишем идеи для этого участка кода
// 
// Вызов my_malloc должен выделить память в куче, но хочется, чтобы это работало быстро, а системный вызов делать дорого.
// Поэтому будем хранить выделеные блоки памяти и пытаться их переиспользовать.
// Для этого у нас будет 2 функции: my_malloc просит блок памяти, my_free помечает блок, как свободный и дальше my_malloc
// сможет возвращать такие блоки.
//
// При вызове my_malloc будем просить на int больше памяти, чтобы туда сохранять размер блока, который мы просили.
// При этом возвращать будет адрес за size. Но мы будет знать, что левее указателя у нас хранится адрес. Показано ниже
// Структура памяти: [ program code ] [ program .data ] [ heap {size| .... } ] ... [ stack ]
my_malloc:
    push    %ebx
    
    mov     heapend, %ebx
    // Увеличиваем heapend на размер, который нас попросили выделить
    mov     8(%esp), %ecx
    add     %ecx, %ebx
    // Увеличиваем размер еще на 4, чтобы разерервировать место под size
    add     $4, %ebx
    
    // Сам вызов brk
    mov     $SYS_brk, %eax
    int     $0x80

    // Свопаем новый heapend и старый:
    // В eax лежит новый конец кучи
    //----
    // перекладываем старый конец кучи в ecx
    mov     heapend, %ecx
    // Новый конец кучи кладем в heapend
    mov     %eax, heapend
    // Старый конец кучи перекладываем в eax
    mov     %ecx, %eax
    //-----
    
    // Теперь нужно сохранить размер.
    // Старый конец кучи = новое начало кучи.
    // Поэтому будет считать от него
    // Сохраняем size: [size|......]
    // В ecx лежит размер памяти, которую нас просили выделить 
    mov     8(%esp), %ecx
    // Кладем этот размер памяти, которую выделили по адресу, который хранится в eax
    // То есть как раз в начало выделенного блока
    mov     %ecx, (%eax)
    // Сдвигаемся на 4, чтобы вернуть корректный адрес (пользователь не знает, что мы просили больше и
    // еще size сохоранили, поэтому для него должно быть проозрачно, что он получил адрес памяти того размера, который просил)
    add     $4, %eax

    pop     %ebx
    ret


    // [heap{size|.....} {size|.....}]
    //                         ^     ^ heapend

// После вызова my_free мы будем немного менять блок памяти, чтобы потом легко найти нужный, когда нас попросят сделать новый my_malloc
// Блок памяти у нас будет теперь так же хранить в "первой ячейке" размер блока, а сразу за ним адрес следующего свободного блока.
// После этого адреса будет что-то лежать, но нас это не волнует. В итоге получится односвязный список из областей памяти, по которому мы будем 
// проходить при вызове my_malloc и пытаться переиспользовать (not implemented).
// меняем память на { size|nextfree .................... }
my_free:
    // На вход ожидаем адрес, который мы вернули при вызове malloc
    // Поэтому знаем, что слева лежит размер блока
    mov     4(%esp), %ecx
    // смотрим на размер блока
    sub     $4, %ecx
    
    // Добавляем новую ноду в наш односвязный список из свободных блоков freelist
    // Будем обновлять начало, то есть наша новая нода будет указывать на старое начало листа
    mov     freelist, %edx
    // Сохраняем адрес начала freelist в нашу ноду в часть, которую мы обозначили nextfree
    mov     %edx, 4(%ecx)
    // Сохраняем адрес начала нашей области в freelist
    mov     %ecx, freelist
    ret

    .data
// Адрес начала кучи
heapstart:
    .int 0
// Адрес конца кучи
heapend:
    .int 0
// head листа с нодами из выделеных блоков памяти
freelist:
    .int 0
