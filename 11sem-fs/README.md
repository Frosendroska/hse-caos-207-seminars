# 11 Семинар 08.02.2022 mmap/fork

## Файлики с кодом:

* [Пример работы mmap](mmap_example.c)
* [Простой fork](simple_fork.c)



# mmap

```
#include <sys/mman.h>

void *mmap(
    void *addr,    /* рекомендуемый адрес отображения, можно передавать NULL, если адрес не важен */
    size_t length, /* размер отображения */
    int prot,      /* аттрибуты доступа */
    int flags,     /* флаги совместного отображения */
    int fd,        /* файловый дескриптор файла */
    off_t offset   /* смещение относительно начала файла */
  );

int munmap(void *addr, size_t length) /* освободить отображение */

```

При ошибке `mmap` возвращает специальное значение `MAP_FAILED`.
Чтобы детектировать ошибку, нужно проверять возвращаемое значение не на `NULL`,
а на `MAP_FAILED`

## Значения prot:

	 PROT_NONE   Pages may not be accessed.
     PROT_READ   Pages may be read.
     PROT_WRITE  Pages may be written.
     PROT_EXEC   Pages may be executed.

Использовать с битовым или: `PROT_READ | PROT_WRITE`

## Значения flags:

* `MAP_FIXED` - требует, чтобы память была выделена по указаному в первом аргументе адресу; без этого флага ядро может выбрать адрес, наиболее близкий к указанному.
* `MAP_ANONYMOUS` - выделить страницы в оперативной памяти, а не связать с файлом. В таком случае значение файлового дескриптора игнорируется.
* `MAP_SHARED` - выделить страницы, разделяемые с другими процессами; в случае с отображением на файл - синхронизировать изменения так, чтобы они были доступны другим процессам.
* `MAP_PRIVATE` - в противоположность `MAP_SHARED`, не делать отображение доступным другим процессам. В случае отображения на файл, он доступен для чтения, а созданные процессом изменения, в файл не сохраняются.

# Fork:

Создание нового процесса осуществляется с помощью системного вызова fork, который создаёт почти точную копию текущего процесса, причём оба процесса продолжают своё выполнение со следующей, после вызова fork, инструкции.

Вновь созданный (сыновний) процесс отличается только своим идентификатором процесса pid и идентификатором родительского процесса ppid. Кроме того, у нового процесса сбрасываются счётчики использования ресурсов, блокировки файлов и ожидающие сигналы.

Сыновний процесс продолжает выполнять тот же код, что и родительский процесс с точки программы, непосредственно после возврата из функции fork. Отличить новый процесс от родительского можно только по возвращаемому системным вызовом fork значению. В сыновний процесс возвращается 0, а в родительский процесс возвращается идентификатор сыновнего процесса. Кроме того, функция fork возвращает число -1, когда новый процесс не может быть создан из-за нехватки ресурсов, либо из-за превышения максимального разрешённого числа процессов для пользователя или всей системы.

Посмотрите лекцию прошлого года.



# References:

* [Лекция с физтеха (mmap)](https://github.com/victor-yacovlev/mipt-diht-caos/tree/master/practice/mmap)
* [Прошлый год (mmap)](https://github.com/blackav/hse-caos-2020/tree/master/14-mmap)
* [Лекция с физтеха (fork)](https://github.com/victor-yacovlev/mipt-diht-caos/tree/master/practice/fork)
* [Прошлый год (fork)](https://github.com/blackav/hse-caos-2020/tree/master/15-fork)
